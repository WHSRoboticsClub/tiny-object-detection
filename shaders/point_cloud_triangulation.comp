#version 450
// GLSL Point Cloud Triangulation

// Issue should wait for all other points to be finished
// Borders

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D depth_samp; // (z, 0, 0, 0)
layout(set = 0, binding = 1) uniform sampler2D class_samp; // (class, ID, 0, 0)

// Need a vec4 to get through to rust without issues
layout(set = 0, binding = 2, r32ui) uniform coherent uimage2D map;

layout(set = 0, binding = 3) buffer Balls {
    vec4 data[100]; // pos, number, 0 // Need a vec4 to get through to rust without issues
    // pos: The a center of the ball
    // number: How many pixels have gone into the average pos (Needed for averaging)
} out_balls;

// Image dims
const uint width = 640;
const uint height = 480;

// Avoidance constants: Going through bots low to the ground is just as
//                      bad as going through tall bots.
const float bot_avoidance_const = 100.0;

// Bump Normalization constants: Taller objects have same area effect as 
//                               shorter objects
const int bot_norm_const = 20;
const int terrain_norm_const = 10;


int int_float_repr(float y, uint max) { 
    return int(y * 4294967295.0 / float(max));
}
/// dump a mound of prespecified height and area effect at a position.
/// Reasoning: This will essentially make traveling through that position
/// suboptimal (how bad is proportional to the height). The area effect 
/// will help ensure clearance.
void bump_img_store(ivec2 pos, float val, int bump_size) {
    // Sigmoid function with constants for clearance
    // let k = calibration constant representing the amount of strong and soft clearance, the
    //         soft: (-inf, point of inflection]  strong: [point of inflection, +inf)
    //           1
    // y = --------------
    //     1 + e^(1.5x/k)
    //
    // select domain: x ∈ [-k, k]
    // range: y ∈ (~0, ~2)

    ivec2 origin = pos - bump_size;
    
    for (int x = 0; x < bump_size*2; x++) {
        for (int y = 0; y < bump_size*2; y++) {
            ivec2 loc = origin + ivec2(x, y); // location
            // proximity (Probably some cheating that can be done here for speed)
            float prox = sqrt(pow(pos.x - loc.x, 2) + pow(pos.y - loc.y, 2)); 
            float y_add = (1.0 / exp(1.5 * prox / bump_size)) * val; // exp = natural exponentiation of param e^param
            
            imageAtomicAdd(map, loc, int_float_repr(y_add, height)); // TODO!!! Must use Atomic Add and integer image type.
        }
    }
}

void store_ball(int id, ivec2 val) { 
    float term = out_balls.data[id].z;
    vec2 new_val = out_balls.data[id].xy * term + val;
    out_balls.data[id] = vec4(new_val / (term + 1), term + 1, 0);
}

void main() {
    uvec2 img_pos = gl_GlobalInvocationID.xy;
    vec2 depth_read = texture(depth_samp, img_pos).xy;
    vec2 class_read = texture(class_samp, img_pos).xy;
    
    int depth = int(depth_read.x) * 1; // TODO scale

    // Not real world pos so that it fits neatly in the Image2D
    ivec3 imgwrld_pos = ivec3(img_pos, depth); 

    int cls = int(class_read.x);
    int id = int(class_read.y);

    // action_ty:
    // 0: follow terrain
    // 1: avoid // Could differentiate between red and blue robots and alter mound
    // 2: goal (go to ball)
    int action_ty = cls;
    if (action_ty != 0) {
        if (action_ty != 1) {
            action_ty -= 1;
        }
    }

    // For indexing it is best to store a birdseye view (xz)
    ivec2 new_pos = imgwrld_pos.xz;

    if (action_ty == 0) { // Terrain
        bump_img_store(new_pos, imgwrld_pos.y, terrain_norm_const);
    } else if (action_ty == 2) { // Ball
        // TODO: instance segmentation set position according to unique id
        store_ball(id, new_pos);
    } else { // Robot
        bump_img_store(new_pos, imgwrld_pos.y, bot_norm_const);
    }
}